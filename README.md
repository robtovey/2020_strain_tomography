# 2020_strain_tomography
Partner code to the paper 'Scanning electron diffraction tomography of strain' with coauthors Duncan Johnstone, Sean Collins, Bill Lionheart, Paul Midgley, Martin Benning and Carola-Bibiane Schoenlieb.

## Reproducing results
The code here is sufficient to reproduce all results of the previously mentioned publication.
Most of the results are of simulated diffraction patterns. The kinematical simulations are computed in python, run the scripts `accuracy_test.py` and `continuum_example.py`. 

The dynamical simulations were performed by MULTEM in MATLAB. The crystals are generated by running the python script `multislice_simulator.py`. The relevant MATLAB code is contained in `doPrecession.m` and `multem_sim.m`. This contains all of the necessary settings and parameters needed to reproduce the simulations although they are missing the clever load/loop/save functionality which simplifies the batch production of the images. I will upload this once I have access to the original file but until that point, if anyone wishes to see the simulated data files then please contact me and I can provide access to them.

The related figures can be generated by the three jupyter notebooks, `test_layered.ipynb`, `test_layered_multislice.ipynb` and `test_continuum.ipynb`. The datasets were too large to be loaded simultaneously on my laptop so the scripts must be re-run modifying the line:
```
n, alpha, rotate = <int>, <float>, <bool>
```
`n` should not be changed but alpha in the set `0, 0.5, 1, 2` and rotate in `True, False`. These parameters correspond exactly to those discussed in the text. Finally, re-run `continuum_example` changing the line 
```
plotting, iso = False, False ---> plotting, iso = True, False
```
This accounts for Figures 3, 4, 5, S.2, S.3 and Table 1.

The reconstruction example can be reproduced by running `piecewise_constant_example.py` replacing the `precomputed` parameter each time. In sequence:
```
precomputed = [False, False, False] <--- computes and plots tilt series
precomputed = [True, False, False]  <--- computes simulated data, reconstruction and plots results
```

## Documentation
The code is not uniformly documented. The kinematical simulation code has been integrated into [diffsims](https://github.com/pyxem/diffsims) which is a more versatile package for performing such computations so this is mainly undocumented. The dyamical simulations used [MULTEM](https://github.com/Ivanlh20/MULTEM) and also has its own general documentation. Computing centres of diffracted spots is also very standard, and an example pipeline shown in the jupyter notebooks using [pyxem](https://github.com/pyxem/pyxem).

I think the main novelty in terms of code are the utilities to convert a tilt series of scans of 2D spot locations into transverse-ray transform data and then use that to perform a reconstruction. The main files for this are `tensor_ray_transform.py`, `recon_lib.py` and `piecewise_constant_example.py`. 

### `recon_lib.py` 
This file contains relatively well optimised utility functions for convex optimisation, in particular TV reconstructions. It is a little excessive for this task but performs very standard methods. In particular, it implements the Primal-Dual Hybrid Gradient method (a.k.a the [Chambolle-Pock algorithm](https://link.springer.com/article/10.1007/s10851-010-0251-1)) with some [accelerations](https://arxiv.org/abs/1305.0546). 

### `piecewise_constant_example.py`
This file demonstrates the recommended usage for reconstruction, essentially the three lines
```
R = getVecProj(...)
problem = TV(...)
recon = problem.run(...)
```
The `weight` parameter should be tuned large for large noise levels and `maxiter` should be chosen to match how much time you are prepared to wait. When `gt` is not known you just omit it from the parameters.

### `tensor_ray_transform.py`
This file is the most novel and hopefully most interesting. There are four documented functions/objects corresponding to X-ray transforms using the [astra toolbox](https://github.com/astra-toolbox/astra-toolbox):
```
getGeneralProjector  --- scalar X-ray projector for non-standard geometries 
vectorProjector      --- component-wise tensor X-ray projection using getGeneralProjector
tensorProjector      --- transverse ray transform in 3D
getVecProj           --- wrapper function to create transverse ray transform
```
While it is very standard to compute lots of 2D spot locations on diffraction patterns, it is less standard to convert these to transverse ray transform data. This can be done with the two utility functions:
```
lift2to3    --- lifts an array of 2D centres to an array of 3D scattering vectors
points2mats --- combines an array of 3D un-scattered vectors with an array of 3D scattered vectors to an array of  tensors
```
There must be at least two non-colinear spots in each diffraction pattern to give a meaningful solution but there is no upper limit. `points2mats` will compute the 'average' strain tensor from given spot centres. If there are different numbers of spots at each tilt then each of these functions could be called once per tilt. Otherwise, zero-padding the detected spots will give the same answer. i.e. inputing lots of detections of the direct beam will not change the tensors returned by `points2mats`.
